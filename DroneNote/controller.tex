\subsection{PID control}A proportional-integral-derivative (PID) controller is a feedback control loop mechanism. The aim is to reach a givenreference value (called set point) for the inputs by regulating its output. The output $u(t)$ of the controller is thesum of three terms that are proportional correspondingly to the error $e(t)$ (P term), the integral of the error (Iterm) and the derivative of the error (D term). Each term is multiplied by a gain, $K_P$,$K_I$ and $K_D$ respectively,that will give their relative importance and fix the properties of the controller: overshoot, reactivity, stability.\begin{equation}	u(t) = K_P e(t) + K_I\int_0^t{e(\tau)d\tau} + K_D \frac{de(t)}{dt}\end{equation}The P term can be interpreted as a response to a perturbation. It is subject to a steady state error that reduces when$K_P$ rises. But increasing $K_P$ also enhances the oscillations of the system. Adding the I term removes the steadystate error as its action continues to affect the output as long as a stable state on the set point has not beenreached. The time to reach the set point is reduced when the gain of the integral term is increased but as for theproportional term it also enhances the oscillations and overshoots. Finally the derivative term acts as a predictiveterm by linear interpolation that helps damping the oscillations%TODO high pass and low pass filters for the derivative term (see astrom-ch6)%TODO address integral windup%TODO address derivative kick%TODO feed forward when changing the setpoint%TODO think about a cascaded PID : the first controls the torque, the second control the motor: % motor_response = PID(measured_torque, PID(sensor, setpoint));%TODO look at the different forms of PID for optimisation%TODO tuning trick\subsection{Speed controller}The controller described in this document is able to drive the drone towards the desired attitude and linear velocity,the set points for this application. The inputs of the controller are the measurements of angular rates, linear velocity andattitude quaternion. The outputs are the torque and thrust that need to be applied on the model.  This goal is reached by cascading two PID controllers. The first one is controlling the linear velocity of the model,using it as an input. As the quadricopter is not able to produce a thrust in any direction but only along its z axis,acting on the acceleration in any other direction can only be achieved by rotating the body frame z axis in theinertial frame. The control on the acceleration is then realized by acting on the total thrust and the orientation ofthe z axis in the inertial frame. The error $\v{v}_e$ is defined as the difference between the reference velocity$\v{v}_{Ref}$ and the measured velocity $\v{v}_m$\begin{equation}	\v{v}_{err} = \v{v}_{Ref} - \v{v}_m\end{equation}%TODO adapt this with the real PID when implemented The total thrust in the inertial frame is proportional to this error but the effect of the gravity has to be taken into account and a constant term is added (feed-forward). Only the disturbances with respect to gravity are taken into account by this controller. \begin{equation} 	\v{T}_{out} = \v{v}_{err} - \v{g} \end{equation}This thrust and the quaternion representing the rotation needed to move the body z axis onto the thrust direction arethe output of this controller and are used as set point for the second.\subsection{Attitude controller}The second controller is used to control the torque applied to the body. It uses the measured attitude quaternion andthe angular rates as input. The error quaternion \q{q_{err}} is the difference quaternion between the reference attitude\q{q_{ref}} and the measured one \q{q_m}.\begin{equation}	\q{q_{err}} = \matrix{w_{err}\\\v{q}_{err}} = \q{q_{ref}}\q{q_{m}}^*\end{equation}As the torque is a vector, only the vector part of the error quaternion is of interest. However the sign of the realpart is important as it gives the direction of the shortest rotation. If it is negative, the represented rotation ismore than $\pi$ radians and the shortest rotation is then the inverse one.\begin{equation}	\v{\tau}_{err} = sign(w_{err})\v{q}_{err}\end{equation}This error will give the proportional term. For the integral term the error quaternion is numerically integrated aftereach measurement (using the tuning change trick\todo{ref}).\begin{equation}	\q{q_{int,N}} = \matrix{w_{int,N}\\\v{q}_{int,N}} = \q{q_{int,N-1}} + \q{q_{err,N}} dt K_{I,a}\end{equation}And the same trick as for the proportional error is applied to get the shortest rotation. \begin{equation}	\v{\tau}_{int} = sign(w_{int})\v{q}_{int}\end{equation}In the case of this controller the derivative term comes for free from the sensor as the derivative of the attitudequaternion is the measured angular rate $\v{\omega}_m$.%Parce que tau = I thetadot ; C'est thetadot qui est régler par le controller et pas tau see control and siimulation pdfThe overall requested torque is multiplied by the inertia matrix, finally giving \begin{equation}	\v{\tau}_{out} = I(\v{\tau}_{err}K_{P,a} - \v{\tau}_{int,N} - \v{\omega}_m K_{D,a})\end{equation}\subsection{Output signal}The last requirement to control the model is to transform the output torque delivered by the attitude controller intooutput values for each motor separately. As a first step, the case where the controller is able to act directly onthe motor rotation speed is considered. The relation between the motors rotation speed and the torque is given by\eq{bodyTau}. The relation between the motors rotation speed and the total thrust \eq{bodyThrust} must be added as anadditional constraint to be able to solve the system.\begin{empheq}[left=\empheqlbrace]{align}&\tau_\phi = L_1k_1\omega_1^2 - L_3k_3\omega_3^2 \\&\tau_\theta = L_2k_2\omega_2^2 - L_4k_4\omega_4^2 \\&\tau_\psi = b_1\omega_1^2 + b_2\omega_2^2 + b_3\omega_3^2 + b_4\omega_4^2 \\&T = k_1\omega_1^2 + k_2\omega_2^2 + k_3\omega_3^2 + k_4\omega_4^2\end{empheq}The solution to this system is \begin{equation}\begin{split}\labeleq{fullMotorSystem}	\omega_1^2 = \inv{D}(&L_3k_3(L_2k_2(b_4T+\tau_\psi k_4)+L_4k_4(b_2T+\tau_\psi k_2)\\	&+\tau_\theta(b_2k_4-b_4k_2))+\tau_\phi (L_2k_2(b_3k_4+b_4k_3)\\	&+L_4k_4(b_2k_3+b_3k_2)))\\ 	 	\omega_2^2 = -\inv{D}(&L_1k_1(L_4k_4(\tau_\psi k_3-b_3T)+\tau_\theta(-b_3k_4-b_4k_3))\\ 	&+L_3k_3(L_4k_4(\tau_\psi k_1-b_1T)+\tau_\theta(-b_1k_4-b_4k_1))\\ 	&+\tau_\phi L_4k_4(b_3k_1-b_1k_3))\\ 	\omega_3^2 = -\inv{D}(&L_1k_1(L_2k_2(-b_4T-\tau_\psi k_4)+L_4k_4(-b_2T-\tau_\psi k_2)\\ 	&+\tau_\theta(b_4k_2-b_2k_4))+\tau_\phi(L_2k_2(b_1k_4+b_4k_1)\\ 	&+L_4k_4(b_1k_2+b_2k_1)))\\ 	\omega_4^2 = -\inv{D}(&L_1k_1(L_2k_2(\tau_\psi k_3-b_3T)+\tau_\theta(b_2k_3+b_3k_2))\\ 	&+L_3k_3(L_2k_2(\tau_\psi k_1-b_1T)+\tau_\theta(b_1k_2+b_2k_1))\\ 	&+\tau_\phi L_2k_2(b_3k_1-b_1k_3)) \end{split}\end{equation}Where the common denominator $D$ is\begin{equation}\begin{split}D = (&L_1k_1(L_2k_2(b_3k_4+b_4k_3)+L_4k_4(b_2k_3+b_3k_2))\\&+L_3k_3(L_2k_2(B_1k_4+b_4k_1)+L_4k_4(B_1k_2+b_2k_1)))\end{split}\end{equation}However, this solution would require a good knowledge of all the motors and body parameters $L_i$, $k_i$, $b_i$ andwould give an absolute output highly linked to the system on which it is installed. Remapping the output to the currentsent to the motors is mainly a scaling operation and would require an additional knowledge on the absolute availablescale $\omega_{i_max}$. A more portable solution would be having an output which is relative to the maximum scale andlinked to the response of the motor to a given input rather than to their parameters. The output of the controller for each motor has to be a power $P_i$ between 0 and 100. The motor rotation speed isgiven by\begin{equation}	\omega_i = \omega_{i,max}\frac{P_i}{100}\end{equation} Replacing it \eq{motorThrust} gives \begin{equation} 	T_i = \left(\frac{\omega_{i,max} P_i}{100}\right)^2 k_i \end{equation} The torque in the body plane $\v{\tau}_{\parallel}$ due to this motor is obtained by making the replacement in equation \eq{bodyTau} \begin{equation} 	\v{\tau}_{\parallel} = \v{L}_iT_i = \left(\frac{\omega_{i,max}^2\v{L}_ik_i}{100^2}\right)P_i^2 = 	\v{R}_{i,\parallel}P_i^2 \end{equation}It's important to notice that the parallel term is a 2 dimensional vector. For the motors on the x axis the secondcomponent (y component) is always zero while for the motors on the y axis the first component (x component)is zero. Similarly for the torque in the z axis $\tau_\perp$ and the thrust $T$ from \eq{bodyTau} and\eq{bodyThrust}\begin{align}	\tau_\perp &= \left(\frac{\omega_{i,max}^2 b_i}{100^2}\right)P_i^2 = R_{i,\perp} P_i^2\\	T &= \left(\frac{\omega_{i,max}^2 k_i}{100^2}\right)P_i^2 = R_{i,T} P_i^2\end{align}Instead of the four initial parameters ($L_i$, $k_i$, $b_i$, $\omega_{i,max}$), each motor is now modelled by a vectorof three reduced parameters $R_i = (\v{R}_{i,\parallel}, R_{i,\perp}, R_{i,T})$ whose advantages will become clear in \sec{Calibration}. The solution\eq{fullMotorSystem} is modified by executing the following replacements.\begin{equation}\begin{split}	\omega_i &\Longleftrightarrow P_i\\	L_ik_i &\Longleftrightarrow R_{i,\parallel}\\	b_i &\Longleftrightarrow R_{i,\perp}\\	k_i &\Longleftrightarrow R_{i,T}\end{split}\end{equation}The valid output range of the controller is now between 0 and 100 and given by:\begin{equation}\begin{split}\labeleq{fullMotorSystem}	P_1^2 = \inv{D}(&R_{3,\parallel}(R_{2,\parallel}(b_4T+\tau_\psi R_{4,T})+R_{4,\parallel}(b_2T+\tau_\psi R_{2,T})\\	&+\tau_\theta(b_2k_4-b_4k_2))+\tau_\phi (R_{2,\parallel}(b_3k_4+b_4k_3)\\	&+R_{4,\parallel}(b_2k_3+b_3k_2)))\\ 	 	P_2^2 = -\inv{D}(&R_{1,\parallel}(R_{4,\parallel}(\tau_\psi R_{3,T}-b_3T)+\tau_\theta(-b_3k_4-b_4k_3))\\ 	&+R_{3,\parallel}(R_{4,\parallel}(\tau_\psi R_{1,T}-b_1T)+\tau_\theta(-b_1k_4-b_4k_1))\\ 	&+\tau_\phi R_{4,\parallel}(b_3k_1-b_1k_3))\\ 	P_3^2 = -\inv{D}(&R_{1,\parallel}(R_{2,\parallel}(-b_4T-\tau_\psi R_{4,T})+R_{4,\parallel}(-b_2T-\tau_\psi 	R_{2,T})\\ 	&+\tau_\theta(b_4k_2-b_2k_4))+\tau_\phi(R_{2,\parallel}(b_1k_4+b_4k_1)\\ 	&+R_{4,\parallel}(b_1k_2+b_2k_1)))\\ 	P_4^2 = -\inv{D}(&R_{1,\parallel}(R_{2,\parallel}(\tau_\psi R_{3,T}-b_3T)+\tau_\theta(b_2k_3+b_3k_2))\\ 	&+R_{3,\parallel}(R_{2,\parallel}(\tau_\psi R_{1,T}-b_1T)+\tau_\theta(b_1k_2+b_2k_1))\\ 	&+\tau_\phi R_{2,\parallel}(b_3k_1-b_1k_3))\\	D = (&R_{1,\parallel}(R_{2,\parallel}(R_{3,\perp}R_{4,T}+R_{4,\perp}R_{3,T})\\	&+R_{4,\parallel}(R_{2,\perp}R_{3,T}+R_{3,\perp}R_{2,T}))\\	&+R_{3,\parallel}(R_{2,\parallel}(R_{1,\perp}R_{4,T}+R_{4,\perp}R_{1,T})\\	&+R_{4,\parallel}(R_{1,\perp}R_{2,T}+R_{2,\perp}R_{1,T})))\end{split}\end{equation}It should be noted that nothing restricts the controller to this range here and that any value outside this range ismeaningless. It should be enforced using the integral windup trick\todo{ref}. 